# [MOOC - Computer Science(컴퓨터공학 입문) I](https://pabi.smartlearn.io/#courses)  
이 문서는 위 MOOC강의를 듣고 필기용으로 기록되었습니다.  

# 개요
컴퓨터를 활용하여 일상 생활에 주어진 문제를 해결할 수 있도록 프로그래밍 기본 원리와 개념을 이해한다.  
문제 해결을 위해 C 언어로 프로그래밍 언어의 기본 구조와 문법을 알고, 그 문법으로 해결할 수 있는 다양한 일상 생활의 문제를 예제를 통해 학습한다.  

# 목차
* [I. 컴퓨터 개요](#i-컴퓨터-개요)
  * [문제 해결(provlem solvoing)](#week-1-1-문제-해결problem-solving)
  * [컴퓨터와 자료표현](#week-1-2-컴퓨터와-자료-표현)
  * [프로그래밍 언어 종류](#week-1-3-프로그래밍-언어-종류)
  * [프로그래밍 개발환경](#week-1-4-프로그래밍-개발환경)
* [Ⅱ. 프로그램 구조](#ⅱ-프로그램-구조)
  * [C언어 구조](#week-2-1-C언어-구조)
  * [변수와 상수](#week-2-2-변수와-상수)
  * [데이터 타입](#week-2-3-데이터-타입)
  * [전처리와 입출력 함수](#week-2-4-전처리와-입출력-함수)
* [Ⅲ. 함수](#ⅲ-함수)
  * [사용자 정의 함수](#week-3-1-사용자-정의-함수)
  * [함수와 매개 변수](#week-3-2-함수와-매개-변수)
  * [함수 호출 방법](#week-3-3-함수-호출-방법)
# I. 컴퓨터 개요  
# WEEK 1-1 문제 해결(problem solving)
문제 입력 → 문제 해결방법과 절차(알고리즘) → 해결 출력
  
## Computational Thinking이란?  
읽기, 쓰기, 셈하기와 더불어 누구나 갖춰야 하는 기본 역략  
컴퓨터과학의 이론, 기술, 도구를 활용하여 현실의 복잡한 문제를 해결하는 사고 방식  
의학, 법, 경제, 정치, 예술 등 사회 모든 분야에서 보편적으로 필요한 핵심 능력(Jeannette M. Wing)  
=> 보통 CT는 일반인과 관계없고 어렵다고 생각되지만 꼭 컴퓨터과학에서 이용되는 것은 아니다.  
  
## 컴퓨터공학 사고력  
위를 바탕으로 CT(컴퓨터공학 사고력)을 재정의하면 다음과 같다.  
주어진 문제를 분석, 이해하고 문제의 해결 방법을 컴퓨터공학의 원리를 적용하여 알고리즘을 도출하고 컴퓨터가 이해하는 프로그래밍 언어로 제시하는 사고능력  
  
## '일반적 문제해결'과 '컴퓨터공학적 문제 해결 과정'의 차이  
1) 일반적 문제 해결
  문제 이해 및 분석 → 문제해결방안탐색 → 해결방법 도출 → 실행 및 평가  
  
2) 컴퓨터공학적 문제 해결과정(총 5가지)  
  * 문제 이해 및 분석 → 컴퓨터 공학적 원리 적용 → 문제 해결 방법의 설계(알고리즘 설계) → 문제 해결 방법의 프로그래밍(알고리즘 구현, 코딩) → 결과 검토  
  * 정보를 처리하는 과정과 방식을 이해하고, 알고리즘을 도출해서 프로그래밍 언어로 명령할 수 있는 사고력이 필요하다.  
  
## 컴퓨터 공학적 문제 해결 방법
### 컴퓨터공학의 원리 적용
  * 데이터 수집: 문제 이해와 분석을 토대로 해결하기 위한 자료를 모으는 단계
  * 자료분석★: 수집된 자료와 문제에 주어진 자료를 세심히 분류하고 분석하는 단계  
  * 데이터표현: 문제의 자료 내용을 토대로 그래프, 차트, 이미지등으로 표현  
  * 문제분석: 문제를 해결해나가기 위해 문제를 모듈로 나누어 분석하는 단계  
  * 추상화: 문제의 복잡도를 줄이기 위해 기본 주요 개념의 일반화 정의를 설정하는 단계  
  * 알고리즘과 절차: 지금까지 문제를 해결하기 위한 과정을 순서적 단계로 표현하는 단계  
  * 자동화: 분석한 문제 중 컴퓨터가 수행할 수 있도록 해결과정을 알고리즘화 하는 단계    
  * 시뮬레이션: 문제해결을 위한 실험모델을 만드는 단계  
### 문제 해결 방법의 설계(알고리즘 설계)  
* 분할 정복(divide and conquere) 알고리즘 → 가장 많이 사용되는 방법  
어떤 문제를 해결하는 알고리즘에서 원래 문제를 성질이 똑같은 여러개의 부분 문제로 나누어 해결하여 원래 문제의 해를 구하는 방식  
![분할정복](https://github.com/jdaun/TIL/blob/master/MOOC/img/divid_and_conquere.PNG)  
* 컴퓨터공학적 문제 해결과정  
의사코드를 작성 후 순서도를 그려보면서 알고리즘을 나타낼 수 있다.    
![의사코드+순서도](https://github.com/jdaun/TIL/blob/master/MOOC/img/pseudo%2Bflow.PNG)  

# WEEK 1-2 컴퓨터와 자료 표현  
## 컴퓨터와 프로그램  
* 컴퓨터  
  전자적으로 계산을 수행하는 장치  
* 프로그램  
  컴퓨터가 수행할 작업을 지시하는 명령어들의 집합  
  → 여기서 명령어란 컴퓨터가 알아들을 수 있는 프로그래밍 언어  
  ![program](https://github.com/jdaun/TIL/blob/master/MOOC/img/program.PNG)  
* 하드웨어  
  컴퓨터를 구성하는 물리적인 장치(device)   
  ex) cpu, ram 등  
* 소프트웨어  
  컴퓨터가 수행할 작업을 지시하는 명령어들의 집합(소스코드 뿐만 아니라 문서포함) = 프로그램의 정의  
  * 시스템 소프트웨어(운영체제, 컴파일러)  
  * 응용 소프트웨어(필요에 의해 만들어진 어플리케이션, 워드 프로세서, 게임)  
## 컴퓨터와 자료 표현
* 자료 표현 원리
  * 2진수(binary) 체계를 사용
  * 전기신호: ON(1), OFF(0)
* 비트(bit)  
  Binary Digit, 0 또는 1의 두 개 정보를 표현하는 정보의 최소 단위  
* 바이트(byte)
  연속된 8개의 비트(256개) 1byte = 8bit, 문자를 표현하는 단위  
## 컴퓨터와 사람의 의사소통  
* 문자 코드
  * N비트의 조합에 일정한 문자를 할당하여 지정한 것을 문자 코드  
  * 국제 표준인 문자 코드는 아스키코드(7bit), 유니코드(16bit)  
* 아스키 코드
  * ASCII(American Standard Code for Information Interchange)  
  * 국제적인 표준으로 문자 코드 체계로서 7비트를 사용하여 128개의 문자, 숫자, 특수문자 코드를 규정  
  * 대문자 A의 코드는 1000001(65)이며, 소문자 a의 코드는 1100001(97)  
## 컴퓨터와 사람의 상호작용
컴퓨터는 0,1 두개의 신호만 가지고 있기 때문에 이진수체계가 편하다.
사람은 16진수, 8진수, 2진수 모두 사용할 수 있다. 그러나 2진수는 직접 계산해서 사용하기에 불편하다.  
컴퓨터는 비트단위롤 사용하는데 2개의 비트로 표현할 수 있는 수는 00,01,10,11과 같이 4개이다.  
사람이 표현할 수 있는 문자를 코드로 만들때 대문자, 소문자, 특수기호 등을 고려하여 128개 정도면 만들수 있다고 생각하였다.  
![binary](https://github.com/jdaun/TIL/blob/master/MOOC/img/binary.PNG)

그래서 만들어진 것이 바로 아스키코드이다.
![binary2](https://github.com/jdaun/TIL/blob/master/MOOC/img/binary2.PNG)

아스키 코드표는 다음과 같다. 0부터 127까지 총 128개를 이루고 있다.  
대문자 A를 2진수로 표현하면 1000001이다.  10진수를 기준으로 1씩 증가하는 모습을 볼 수 있다.  
특수기호와 다르게 알파벳은 순서를 부여하고 있다.  
컴퓨터는 문자를 숫자로 처리가 가능하다. 따라서 문자에서 더하고 빼는 것이 가능하다.  
![ascii](https://github.com/jdaun/TIL/blob/master/MOOC/img/ascii.PNG)

# WEEK 1-3 프로그래밍 언어 종류
## 프로그래밍 언어
* 프로그래밍 언어의 필요성
  * 사람과 컴퓨터가 의사소통을 하기 위해서 만든 언어
  * 사람이 컴퓨터에게 지시할 ㅁ여령어를 기술하기 위해 만들어진 언어
* 프로그래밍 언어의 종류
  * 저급언어(low level language): 기계어, 어셈블리어
  * 고급언어(high level language): C, C++, Java, Python
* 컴파일러  
  고급언어로 작성된 프로그램을 기계어로 번역
* 어셈블러  
  어셈블리 언어로 작성된 프로그램을 기계어로 번역
![compiler](https://github.com/jdaun/TIL/blob/master/MOOC/img/compiler.PNG)
* 운영체제와 프로그래밍 언어
![os](https://github.com/jdaun/TIL/blob/master/MOOC/img/os.PNG)
* 프로그래밍 언어 종류  
  * C(1972): 데니스 리치(Dennis Ritchie)  
   - 유닉스(UNIX): 운영체제 작성을 위해 시스템 프로그래밍 언어로 설계된 언어
  * C++(1983)  
    -C언어가 가지는 장점을 그대로 계승하면서 객체의 상속성 등의 개념을 추가한 효과적인 언어 
    -C++ 컴파일러는 C컴파일 가능  
  * 자바(1992)  
    -자바의 시초는 1992년 미국 SUN사에서 가전 제품들을 제어하기 위한 언어에서 비롯됨
    -객체지향 프로그래밍 언어
    -분산 네트워크상에서의 프로그래밍이 용이
  * 파이썬(1992)  
    -1991년 Guido van Rossum에 의해 발표
    -플랫폼 독립적
    -인터프리터 언어
    -동적 타이핑 언어
    -AI 프로그래밍을 위한 많은 라이브러리 제공
    -처음 C언어로 개발
    -인공지능의 발전과 함께 확산중  
    
# WEEK 1-4 프로그래밍 개발환경
## 컴퓨터 프로그램
* 프로그램  
  컴퓨터에게 어떤 일의 수행을 지시하는 명령어들의 집합(실행파일, hello.exe)
## 프로그램 개발 도구
  * 에디터(editor)  
    * 소스코드를 작성할 수 있는 문서 편집기
    * 메모장에 소스코드를 작성 후 hello.c로 저장  
  * 컴파일러(compiler)
    * 에디터로 작성된 소스코드를 기계어로 번역해주는 프로그램(Turbo C, GNU C(gcc))
    * 다양한 운영체제에서 C컴파일러 사용 가능
  * 링커(linker)
    * 번역된 여러 목적코드를 하나로 묶어주는 역할
    * 목적(object)코드: 번역된 명령어(기계어)
  * 디버거(debugger)
    * 프로그램 오류를 수정하는 도구
    * 명령을 줄 단위로 실행하고 결과 확인 가능
  * 통합개발환경(_위의 모든것을 합친 것!_\)
    * 에디터, 컴파일러, 링커, 디버거 기능을 모두 제공하는 프로그램(DevC++, VS)
    * https://ideone.com/ 에서 실습 가능
## 실행파일 생성 및 실행 과정
우리가 작성한 소스파일(hello.c)은 컴파일러에 의해서 목적파일(hello.obj)이 만들어지게 된다.
목적파일은 기계가 이해할 수 있는 언어이며 링커로 여러개의 파일을 하나로 묶어서 실행파일을 생성한다.  
그리고 로더의 역할로 메모리를 거쳐서 프로그램을 실행하게 된다.  
![compileprocess](https://github.com/jdaun/TIL/blob/master/MOOC/img/compileprocess.PNG)


# Ⅱ. 프로그램 구조  
# WEEK 2-1 C언어 구조  
## C언어 역사  
  * 유닉스(Unix)라는 운영체제의 호환성을 높이기 위해 1972년 경 B언어를 재개발하면서 생성되었다.  
  * 1983년 미국표준협회에서 ANSI C라는 표준안을 발표  
  * C++, Java, Python등 많은 프로그래밍 언어의 기초 문법 포함  
## 일반적인 프로그램 구조(모듈화) 
![problemsolving](https://github.com/jdaun/TIL/blob/master/MOOC/img/problemsolving.PNG)  

위 블록의 각각은 C언어에서 아래와 같이 함수로 나타낼 수 있다.  

## C언어 구조 - 여러 개의 함수로 구성  
![c_architecture](https://github.com/jdaun/TIL/blob/master/MOOC/img/c_architecture.PNG)  

여기서 함수는 앞의 모듈의 개념이다. 반복되는 기능을 막고 필요할 때마다 함수를 불러서 사용한다.  
제일 처음 시작하는 함수를 메인함수라 하고, 뒤에 나오는 함수들은 사용자가 정의해서 사용할 수 있는 함수를 의미한다.  
메인함수가 오기 전에 '함수 밖 명령'에서 프로그램을 실행하기 전 만들어줘야 하는 내용들을 나열한다.

사용자에게 두개의 입력값을 받아 더해서 출력하는 간단한 프로그램을 C언어 구조와 함께 보면 다음과 같다.

![c_architecture2](https://github.com/jdaun/TIL/blob/master/MOOC/img/c_architecture2.PNG)  

* #include: 전처리지시자, 컴파일러가 기계어로 바꾸기 전에 <stdio.h>라는 헤더파일을 소스코드에 포함시켜달라는 의미
* return 0: 나를 호출한 쪽으로 '0'을 넣어서 돌아가라 => 프로그램이 성공적으로 끝났음을 의미
* c언어의 함수는 시스템에서 제공하는 1)라이브러리 함수, 2)메인 함수, 3)사용자 정의함수 로 정의할 수 있다. 

## C프로그램 실행 순서
![c_procedure](https://github.com/jdaun/TIL/blob/master/MOOC/img/c_procedure.PNG)

# WEEK 2-2 변수와 상수
## 주석(comment)  
  * 프로그램 소스코드만으로 사람이 이해하는 것에 어려움이 있음
  * 프로그램의 이해를 돕기 위해 주석 사용
  * C주석: /*   */
  * C++주석: // 줄단위
## 예약어(keyword)
  * 약속된 의미의 단어
  * 예약어는 약속된 의미로만 사용
  * 사용자가 임의로 재정의해서 사용할 수 없음
## 식별자(identifier)
  * 사용자가 만든 이름(변수명, 함수명 등)
  * 영문대소문자 따로 구별(abc, Abc등 다른 식별자)
  * 영문대소문자, 밑줄(언더스코어 _), 숫자를 혼합하여 만듦
  * 첫 자는 숫자가 오면 안됨
  * 잘못된 식별자 예
    ex) 1abc, @address, float ,#student,Your Name
## 상수(constant)
  * 프로그램 내에서 항상 고정된 값을 의미
  ![constant](https://github.com/jdaun/TIL/blob/master/MOOC/img/constant.PNG)  
## 변수(variable)
  * 수학에서 변수: 변할 수 있는 수를 의미
  * C언어에서 변수
    * 데이터를 메모리에 저장하는 공간
    * 데이터를 처리하기 위해서는 데이터 타입을 이용해 변수를 선언
  ![variable](https://github.com/jdaun/TIL/blob/master/MOOC/img/variable.PNG)  
  오른쪽은 메인메모리를 그린 것으로 1씩 증가하는 각 주소(번지)를 가지고 있다.  
  변수란 저장공간이고 이 공간의 이름이 변수명이 된다.
  문자상수는 보통 1바이트, int형과 float형은 4바이트에 저장된다.
## 연산자(operator) _뒷부분에서 자세히 배울 예정_
  * 수행되는 연산을 표현하는 기호 
  * 산술 연산자
  * 관계 연산자
  * 대입 연산자
  * 논리 연산자
  * 증감 연산자
  * 조건 연산자
  * 비트 연산자
  * sizeof 연산자
  * 형변환 연산자
## 표현식(expression)
  * 상수, 변수, 연산자, 함수 호출 등으로 구성된 의미 있는 식
  * 상수, 변수, 함수 호출은 그 자체를 표현식이라 볼 수 있음
  * 표현식은 항상 평가값을 가짐
  ex) a+b, 3.14, printf("Hello")
## 문장(statement)
  * 하나의 처리 단위(문장)는 반드시 세미클론(;)으로 끝내야 함  
  * 컴파일러에게 처리 단위를 알려주는 역할
  * 복합문
    * 여러 문장을 묶어서 하나의 문장처럼 처리
    * 중괄호{} 이용
  * 대입문(assignment statement)
    * 대입 연산자(=)는 오른쪽에 있는 표현식의 평가값을 왼쪽 변수에 저장  
    ![assignment_statement](https://github.com/jdaun/TIL/blob/master/MOOC/img/assignment_statement.PNG)  
    
# WEEK 2-3 데이터 타입
## 데이터 타입
  * 데이터 처리를 위해서는 데이터를 저장해야 함
  * 데이터를 종류에 따라 분류하여 적절한 크기의 공간에 저장하기 위해 데이터 타입 필요
  * 변수에 저장되는 값의 종류를 데이터 타입(data types) 또는 간단히 자료형
    * 기본 자료형(basic type): int, char, float ...
    * 유도 자료형(derived type): 배열, 구조체, 공용체 ...
## 변수 선언
  * 변수: 프로그램에서 자료 값을 임시로 기억할 수 있는 저장 공간
  * 컴퓨터의 메모리인 RAM(Random Access Memory)에 저장
  * 변수명은 자료값을 저장하는 저장 장소의 이름
  * 같은 데이터 타입 변수 여러 개 선언시 콤마(,) 사용 (예: int a, b, c;)
  ![C 기본 데이터 타입](https://github.com/jdaun/TIL/blob/master/MOOC/img/data_type.PNG)
## 정수형
* 정수형은 큰 의미에서는 문자형을 포함
* 좁은 의미에서는 문자형을 제외한 순수하게 정수를 저장하는 자료형
* signed int의 범위
  * 정수 자료형 signed int의 크기가 32비트(4바이트)이면 음수부터 양수까지 표현이 가능하므로 -2^31에서부터 2^31-1까지 표현이 가능
* unsigned int의 범위
  * 0과 양수만 표현
## 문자형은 왜 정수형일까?
* 문자형: char
* ASCII 코드로 저장되는 문자는 정수값으로 연산 가능하기 때문에
ex) 문자형 연산 예
```c
char c1 = 'a';
c1 = c1 + 1;
printf("%c", c1); //'b'
printf("%d", c1); //98
```
## 부동소수형
* float의 저장공간 크기: 32비트(4바이트)
  * 표현 범위는 대략 1-^-38에서 10^38이고, 소숫점 이하 6자리까지 표현이 가능
* double의 저장공간 크기: 64비트(8바이트)
  * double은 float보다 표현 범위가 크고, 정밀도도 정확하게 표현
  * 표현 범위는 대략 10^-308에서 10^308이고, 소숫점 이하 15자리까지 표현
* long double: double보다 더 큰 저장공간을 할당하려는 의도에서 만들어졌으나 컴파일러마다 다르고 보통 8바이트로 같이 부여되어 있는 경우가 많다.
## sizeof 연산자
* sizeof 연산자
  * 저장공간의 크기를 알 수 있는 연산자로 sizeof를 이용
  * 연산자 sizeof 다음의 변수 이름으로 둘러싸는 괄호는 생략 가능  
  * 결과 값은 크기의 바이트 값
* sizeof 이용법  
  sizeof (변수)    
  sizeof 변수  
  sizeof (자료형키워드)  
  
# WEEK2-4 전처리와 입출력 함수
## 전처리기(preprocessor)
컴파일러가 프로그래밍 언어를 기계어로 바꾸기 전에 처리해야할 명렁을 먼저 수행하는 것
  * 다양한 라이브러리를 작업 중인 소스파일에서 사용할 수 있도록 헤더 파일을 포함(#include<stdio.h>)  
  * #include  
  ![전처리기_include](https://github.com/jdaun/TIL/blob/master/MOOC/img/preprocessor_include.PNG)  
  #include<stdio.h>가 실행되면 전처리기는 stdio.h(헤더파일)에 있는 소스코드를 source.c에 뿌려주는 역할을 한다.  
  * #define 문자열1 문자열2 //컴파일 전에 소스파일의 문자열1을 문자열2로 치환  
  ![전처리기_define](https://github.com/jdaun/TIL/blob/master/MOOC/img/preprocessor_define.PNG)   
  프로그램에서 3.141592가 계속 사용되는 경우, 이를 PI로 치환하면 컴파일 전에 전처리기에 의해서 다시 원래값인 3.141592로 치환이 된다.  
## printf함수
여러개의 다양한 데이터타입을 형식화시켜 출력하는 함수
  * 문자열 출력  
  예) printf("Hello World\n");
  * 변수값 출력  
  ```c
  int a, b;
  float c;
  printf("%d %f %d\n", a, c, b);
  printf("The number %d is my favorite number.\n", num);
  ```
  ![형식지정자](https://github.com/jdaun/TIL/blob/master/MOOC/img/format.PNG)
## scanf함수
여러개의 다양한 데이터타입을 한 번에 입력받을 수 있는 함수
* 키보드로부터 입력된 데이터를 지정된 형식으로 변환하여 변수에 저장
```c
int a;
scanf("%d", &a); //&는 주소연산자
```
* 임의의 개수로 입력 받을 수 있음  
예1)
```c
int age;
float weight;
scanf("%d %f", &age, &weight);
```
예2)
```c
double d1, d2;
scanf("%lf %lf", &d1, &d2);
```

## 예제 프로그램
마일(mile)을 킬로미터(kilometer)로 변환
* 입력 데이터: miles
* 출력 데이터: kilometer
* 관련 수식: 1mile = 1.609kilometers
* 알고리즘
1. 마일(miles)데이터를 입력 받는다.  
2. 마일을 킬로미터로 변환한다. 2.1(1mile = 1.609kilometers)  
3. 킬로미터를 출력한다.
```c
#include <stdio.h> /*printf, scanf 함수 원형*/
int main(void)
{
  double miles, kilometers;
  /*1*/
  printf("Enter the distance in miles");
  scanf("%lf", &miles);
  /*2*/
  kilometer = 1.609*miles;
  /*3*/
  printf("That equals %f kilometers. \n", kilometer);
  return 0;
}
```


# Ⅲ. 함수
# WEEK 3-1 사용자 정의 함수
## 함수의 개념
독립적으로 수행하는 프로그램 단위  
* C언어는 여러 개의 함수들로 이루어짐.
* 프로그램에서 반복적으로 수행되는 기능을 함수로 만들어 호출.
* 함수는 문제 해결의 방법
  * 주어진 문제를 작은 문제, 즉 여러 함수로 나누어 생각할 수 있으므로 함수를 만드는 것은 문제 해결의 하나의 방법
* 함수 이용의 장점
  * 함수로 구성된 프로그램은 함수 단위로 구성되어 있어, 읽기 쉽고, 이해하기 쉬움
  * 이미 정의된 함수는 여러 번 호출이 가능하므로 소스의 중복을 최소화하여 프로그램의 양을 줄이는 효과
## C프로그램 함수의 종류
1. 주(main)함수: 프로그램의 시작과 종료를 나타내는 함수로, 프로그램에 main()함수는 꼭 있어야 하는 함수이며, 사용자 저으이 함수라 할 수 있음  
2. 사용자 정의 함수: 사용자(프로그래머)가 문제를 분석하여 필요한 기능으로 분류하여 기능별로 코딩하고자 할 때 만드는 함수 예)add(), swap()  
3. 시스템 라이브러리 함수: 많이 사용하는 기능의 함수들을 시스템에서 미리 만들어 놓고 사용자가 사용할 수 있도록 제공하는 함수 예)입출력함수(scanf(), printf())  
## 함수의 정의(Function definition): 함수 만들기
두개의 정수를 매개변수로 입력받아 더한 값을 리턴하는 함수 만들기  
```c
int add(int x, int y)//함수의 머리, int-리턴타입, add-함수이름, int x, int y - 매개변수 리스트)
//함수의 몸체
{
int sum;
sum=x+y;
return sum;
}
```
## 사용자 정의 함수 만들기
![사용자정의함수](https://github.com/jdaun/TIL/blob/master/MOOC/img/userfunction.PNG)  

초기에 a,b,sum 메모리 공간에는 0이 있다.

## 용어 정리  
* 변수(variable)    
프로그램에서 데이터를 저장하는 공간    
* 변수명(variable name)  
선언된 변수의 메모리에 붙여진 이름   
  * 변수명에 다른 값을 대입하면 예전 값은 지워지고 새로운 값을 저장(int a=10; a=100;)  
* 데이터 타입(data types, 자료유형, 자료형)  
변수를 선언할 때, 변수의 특성에 적합한 메모리를 할당하도록 만들어 놓은 예약어    
(예: int, char, double)  
* 함수(function, 모듈, 메소드(C++, JAVA))  
프로그램에서 기능별로 나누고 독립적으로 실행할 수 있는 프로그램 단위   
* 함수 정의(function definition)  
함수를 만드는 것  
* 함수 원형(function prototype, 함수 선언)  
함수를 사용(호출)하기 이전에 함수의 머리(헤더)부분을 기술하는 단계  

# WEEK 3-2 함수와 매개 변수
## 매개변수 없는 함수 만들기
![매개변수없는함수](https://github.com/jdaun/TIL/blob/master/MOOC/img/function_without_parm.PNG)  

hello()에 대한 정보를 컴파일러에게 알려주기 위해 메인함수 위에 함수원형(함수의 프로토타입)을 적어주어야 한다.  
이때, 매개변수의 형식과 리턴타입을 포함해준다.  

## 매개변수 있는 함수 만들기 - 함수 호출 방법: 값에 의한 호출(call by value)
![매개변수있는함수](https://github.com/jdaun/TIL/blob/master/MOOC/img/function_with_param.PNG)  

add()함수의 지역변수들의 메모리는 함수가 호출되면 생성되고, 종료될때 사라지므로 메모리의 효율성을 알 수 있다.  
함수를 호출할때는 값을 넣어서 보내서 값을 쓰고 다시 갖고 돌아온다. 이러한 함수 호출 방법을 call by value라 한다.  

## 용어정리
* 매개변수(parameter, 인자, argument)
  * 함수와 함수 사이에 주고 받는 값(예: 변수값, 상수값 등)
* 변수(variable)
  * 프로그램에서 데이터를 저장하는 공간
  * 지역변수: 함수 지역 안에서 선언된 변수는 다른 변수에서 그 내용을 보거나 수정할 수 없음
  
# WEEK 3-3 함수 호출 방법
## 성적 처리를 위한 주요 함수 만들기
* 총점을 반영하여 성적순으로 정렬하는 프로그램을 만들고자 한다. 두가지 함수를 생성한다.
* 총점 구하기 - add()
* 정렬을 위해 두 변수의 값을 서로 바꾸는 함수가 필요하다 - swap()
## 생각하기: 두개의 변수 값을 서로 바꾸려면?
![swap](https://github.com/jdaun/TIL/blob/master/MOOC/img/swap.PNG)  
a=10, b=20이 저장되어 있다고 가정할 때, 서로 값을 바꿔 주기 위해 a=b, b=a를 해주게 되면 a에 b값이 들어가는 순간 기존의 a에 저장된 10은 사라져버리기 때문에 b=a=20가 되어 버린다.  
따라서, 방(temp)을 하나 만들어서  
1) a의 값을 temp에 넣는다.  
2) b의 값을 a에 넣는다.
3) temp의 값을 b에 넣는다.  
이 순서로 a=20, b=10이 되어 두개의 변수값이 바뀐다.  
이 알고리즘은 추후 데이터 정렬시에도 기본적으로 많이 적용된다.  
## 더 생각하기: 다른 함수를 통해서 두 개의 변수 값을 서로 바꾸려면?
main함수에 있는 변수 두 개의 값을 정렬을 위해 서로 바꾸고 싶은데 자주 사용되는 기능이므로 함수를 만들어서 호출하고 싶다면?  
* 문제 해결하기  
main안에 변수 값을 temp변수를 사용하여 서로 변경하면 바뀌지만, 다른 함수로 두 변수 값을 call by  value보내서 바꾼다면 지역변수 특성상 main함수 영역에 있는 변수 값을 두 개 모두 바꿀 수 없다.(return은 1개 값만 가지고 올 수 있으므로)  

따라서 이를 해결하기 위해 나온 것이 call by address이다.


## 함수 호출 방법: 주소에 의한 호출(call by address)
* 해결 방법
  * main함수에 있는 변수의 조건값을 가지고 swap()함수를 호출하면 swap()함수에서 main함수의 변수 값을 바꿀 수 있음(포인터 변수 사용)
  * 바꾸기 위해서는 역참조 연산자를 사용해야 함
* 용어정리
  * 표인터 변수: 주소를 값으로 가지는 변수  
  주소값을 저장하기 위해서는 포인터 변수가 필요하다.  
  * 포인터 변수 선언: int *p, int *q  
  * 포인터 변수는 주소값만 값으로 가질 수 있음(int *p = &a) //&는 주소를 나타낸다.  
  P = &a
  * 역참조 연산자: 포인터 변수 선언 후에 문자 중에 포인터 변수 앞에 *가 오면(*p) 포인터 변수가 가리키는 main변수의 값을 변경할 수 있음  
  * *두가지 용법    
  1) 포인터 변수 선언  
  2) 역참조 선언  

다음은 두개의 변수의 값을 바꾸는 프로그램이다.
![call_by_reference](https://github.com/jdaun/TIL/blob/master/MOOC/img/call_by_reference.PNG)  
a와 b의 주소를 swap으로 넘기면 이 정보를 담을 방이 필요하다.  
따라서, 주소를 값으로 저장할 수 있는 포인터 변수에 저장을 한다.  
그리고 temp를 선언해서 p가 가리키는 곳(=*p=a)와 q가 가리키는 곳(=*q=b)의 값을 바꿔준다.  

```c
#include<stdio.h>
int sum(int a, int b); //함수 원형
void swap(int *p, int * q) //함수 원형
int main(void)
{
  int a, b, total;
  printf("Input two integers: ");
  scanf("%d%d", &a, &b); //10, 20
  printf("a: %d, b: %d\n", a, b);
  total = sum(a,b);
}

int sum(int a, int b){
  int total;
  total = a+b;
  return total;
}

void swap(int *p, int *q){
  int temp;
  temp = *p;
  *p = *q;
  *q = temp;
}
```   



